# js-tokens

利用正则做 JS 词法解析，早些时候我认为不可能，因为词法解析需要一个状态机模式，正则很难做多状态下的转换和处理。

举个简单例子：

```js
a/b/c+/e+f/g
```

其中的 “/” 哪个是除号，哪个是正则字面量，是如何分用正则析出来呢？

后来看到了官方 JS 的 [TMLanguage.json](https://github.com/microsoft/vscode/blob/master/extensions/javascript/syntaxes/JavaScript.tmLanguage.json)，其复杂程度让人窒息，然后觉得这个事情倒不是不可能。

当然 TMLanguage.json 并不只是一个正则，本身也有状态切换。js-token 能用一个正则解决这个问题，的确让人好奇。

## js-token 正则

js-tokens 的 正则是用 CoffeeScript 写的，笔者不懂 CoffeeScript，不过里面仅用到了 CoffeeScript 正则字面量语法，学起来不复杂。

### CoffeeScript 正则字面量（Heregexes）

CoffeeScript 采用 Heregexes 正则语法，可以忽视内部空白字符，同时可以增添注释。因此 CoffeeScript 的正则可以加 注释、缩进，维护性要比 JavaScript 好很多。

使用 /// 开始定义正则，同样使用 /// 结束正则定义。

使用 # 注释。

## js-token 正则源码

js-token 的源码很简单，以至于笔者不想删减，直接奉上：

```CoffeeScript
///
  ( # <string>
    ([ ' " ])
    (?:
      (?! \2 )[^ \\ \n \r ]
      |
      \\(?: \r\n | [\s\S] )
    )*
    (\2)?
    |
    `
    (?:
      [^ ` \\ $ ]
      |
      \\[\s\S]
      |
      \$(?!\{)
      |
      \$\{
      (?:
        [^{}]
        |
        \{ [^}]* \}?
      )*
      \}?
    )*
    (`)?
  )
  |
  ( # <comment>
    //.*
  )
  |
  ( # <comment>
    /\*
    (?:
      [^*]
      |
      \*(?!/)
    )*
    ( \*/ )?
  )
  |
  ( # <regex>
    /(?!\*)
    (?:
      \[
      (?:
        (?![ \] \\ ]).
        |
        \\.
      )*
      \]
      |
      (?![ / \] \\ ]).
      |
      \\.
    )+
    /
    (?:
      (?!
        \s*
        (?:
          \b
          |
          [ \u0080-\uFFFF $ \\ ' " ~ ( { ]
          |
          [ + \- ! ](?!=)
          |
          \.?\d
        )
      )
      |
      [ g m i y u s ]{1,6} \b
      (?!
        [ \u0080-\uFFFF $ \\ ]
        |
        \s*
        (?:
          [ + \- * % & | ^ < > ! = ? ( { ]
          |
          /(?! [ / * ] )
        )
      )
    )
  )
  |
  ( # <number>
    0[xX][ \d a-f A-F ]+
    |
    0[oO][0-7]+
    |
    0[bB][01]+
    |
    (?:
      \d*\.\d+
      |
      \d+\.? # Support one trailing dot for integers only.
    )
    (?: [eE][+-]?\d+ )?
  )
  |
  ( # <name>
    # See <http://mathiasbynens.be/notes/javascript-identifiers>.
    (?!\d)
    (?:
      (?!\s)[ $ \w \u0080-\uFFFF ]
      |
      \\u[ \d a-f A-F ]{4}
      |
      \\u\{[ \d a-f A-F ]+\}
    )+
  )
  |
  ( # <punctuator>
    -- | \+\+
    |
    && | \|\|
    |
    =>
    |
    \.{3}
    |
    (?:
      [ + \- / % & | ^ ]
      |
      \*{1,2}
      |
      <{1,2} | >{1,3}
      |
      !=? | ={1,2}
    )=?
    |
    [ ? ~ . , : ; [ \] ( ) { } ]
  )
  |
  ( # <whitespace>
    \s+
  )
  |
  ( # <invalid>
    ^$ # Empty.
    |
    [\s\S] # Catch-all rule for anything not matched by the above.
  )
///g
```

为了方便看，用 [regexper 提供的状态图](https://regexper.com/#%28%28%5B'%22%5D%29%28%3F%3A%28%3F!%5C2%29%5B%5E%5C%5C%5Cn%5Cr%5D%7C%5C%5C%28%3F%3A%5Cr%5Cn%7C%5B%5Cs%5CS%5D%29%29*%28%5C2%29%3F%7C%60%28%3F%3A%5B%5E%60%5C%5C%24%5D%7C%5C%5C%5B%5Cs%5CS%5D%7C%5C%24%28%3F!%5C%7B%29%7C%5C%24%5C%7B%28%3F%3A%5B%5E%7B%7D%5D%7C%5C%7B%5B%5E%7D%5D*%5C%7D%3F%29*%5C%7D%3F%29*%28%60%29%3F%29%7C%28%5C%2F%5C%2F.*%29%7C%28%5C%2F%5C*%28%3F%3A%5B%5E*%5D%7C%5C*%28%3F!%5C%2F%29%29*%28%5C*%5C%2F%29%3F%29%7C%28%5C%2F%28%3F!%5C*%29%28%3F%3A%5C%5B%28%3F%3A%28%3F!%5B%5C%5D%5C%5C%5D%29.%7C%5C%5C.%29*%5C%5D%7C%28%3F!%5B%5C%2F%5C%5D%5C%5C%5D%29.%7C%5C%5C.%29%2B%5C%2F%28%3F%3A%28%3F!%5Cs*%28%3F%3A%5Cb%7C%5B%5Cu0080-%5CuFFFF%24%5C%5C'%22~%28%7B%5D%7C%5B%2B%5C-!%5D%28%3F!%3D%29%7C%5C.%3F%5Cd%29%29%7C%5Bgmiyus%5D%7B1%2C6%7D%5Cb%28%3F!%5B%5Cu0080-%5CuFFFF%24%5C%5C%5D%7C%5Cs*%28%3F%3A%5B%2B%5C-*%25%26%7C%5E%3C%3E!%3D%3F%28%7B%5D%7C%5C%2F%28%3F!%5B%5C%2F*%5D%29%29%29%29%29%7C%280%5BxX%5D%5B%5Cda-fA-F%5D%2B%7C0%5BoO%5D%5B0-7%5D%2B%7C0%5BbB%5D%5B01%5D%2B%7C%28%3F%3A%5Cd*%5C.%5Cd%2B%7C%5Cd%2B%5C.%3F%29%28%3F%3A%5BeE%5D%5B%2B-%5D%3F%5Cd%2B%29%3F%29%7C%28%28%3F!%5Cd%29%28%3F%3A%28%3F!%5Cs%29%5B%24%5Cw%5Cu0080-%5CuFFFF%5D%7C%5C%5Cu%5B%5Cda-fA-F%5D%7B4%7D%7C%5C%5Cu%5C%7B%5B%5Cda-fA-F%5D%2B%5C%7D%29%2B%29%7C%28--%7C%5C%2B%5C%2B%7C%26%26%7C%5C%7C%5C%7C%7C%3D%3E%7C%5C.%7B3%7D%7C%28%3F%3A%5B%2B%5C-%5C%2F%25%26%7C%5E%5D%7C%5C*%7B1%2C2%7D%7C%3C%7B1%2C2%7D%7C%3E%7B1%2C3%7D%7C!%3D%3F%7C%3D%7B1%2C2%7D%29%3D%3F%7C%5B%3F~.%2C%3A%3B%5B%5C%5D%28%29%7B%7D%5D%29%7C%28%5Cs%2B%29%7C%28%5E%24%7C%5B%5Cs%5CS%5D%29)。

源码分为几段，包括字符串字面量（模板字符串字面量）、注释、标识、数字字面量、正则等几部分。每个部分用 | 链接，

```CoffeeScript
///
 (部分1)
 | (部分2)
 | (部分3)
///g
```

这样使用字符串的 [match](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match)，可以一次性地完成分词，识别出全部 token:

```javascript
jsSource.match(jsToken)
```

再看每一个部分的共性，绝大部分都是符合以下格式的：

开始标记 （内容1 | 内容2 | 内容...)* (结束标记)?

结束标记可省，是防止源码不完整没有结束符号的情况。

### 字符串

#### 普通字符串

```CoffeeScript
///
([ ' " ])
(?:
  (?! \2 )[^ \\ \n \r ]
  |
  \\(?: \r\n | [\s\S] )
)*
(\2)?
///
```

先识别字符串标记符合 `'` 和 `"`，并使用 \2 做分组引用。js 的正则中，并不只支持分组命名，所以只能用出现的位置做组名。

然后是字符串内容，需要注意的是对转义的处理。

对于不转义的字符，使用负向零宽先行断言 `(?! \2 )` ，保证内容中不出再出现 串标记符合。`[^ \\ \n \r ]` 处理非转义字符，也就是说只要不是 `\\`、 `\n`、`\r` 的字符，都可以出现在字符串的中的。

对于转义字符，`\\(?: \r\n | [\s\S] )` 的识别转义，`[\s\S]` 表示所有字符，当然也包括 `'` 和 `"`；`\r\n` 是处理续行符，续行符属于 LineTerminatorSequence [LineTerminatorSequence](https://tc39.es/ecma262/#prod-LineTerminatorSequence)，有5种情况，仅一种情况有两个字符。

因为转义字符的 `\ + 内容` 都是成对出现的，因此不会有 “\\” 导致识别不清楚的情况。

最终由 \2 识别字符串的结束。

#### 模板字符串

```coffeescript
///
  `
  (?:
    [^ ` \\ $ ]
    |
    \\[\s\S]
    |
    \$(?!\{)
    |
    \$\{
    (?:
      [^{}]
      |
      \{ [^}]* \}?
    )*
    \}?
  )*
  (`)?
///
```

非插值部分，和普通字符串一样，设置。插值部分，理论上会非常复杂，因为插值是可以嵌套任何表达式的，甚至表达 字符串模板的表达式。js-token 对模板字符串插值处理就非常简单了，首先他不去识别插值的内容，处理插值仅是为了确定模板字符串结束标记“`” 的位置。

```coffeescript
///
  \$\{
  (?:
    [^{}]
    |
    \{ [^}]* \}?
  )*
  \}?
///
```

`\{ [^}]* \}?` 是处理插值中，有成对出现的大括号情况，防止 } 匹配错误的情况。js-token 对这种情况非常吃力，仅能匹配一个 {}，还不能排除内嵌字符串里吗的 } 情况。

#### 小结

* 分组
* 使用 负向零宽先行断言，确保不会出现某字符
* 续航符
* 对插值处理

### 注释

#### 单行注释

最简单的一个：

```CoffeeScript
///
  ( # <comment>
    //.*
  )
///
```

`.*` 即可，因 `.` 不含有换行，因此都不用做换行检测了。

#### 多行注释

```CoffeeScript
( # <comment>
  /\*
  (?:
    [^*]
    |
    \*(?!/)
  )*
  ( \*/ )?
)
```

字符串搞明白后，看这个就很简单了，再次使用 `负向零宽先行断言`，与字符串不同点是，`负向零宽先行断言` 后面没有内容，因为后面的内容不需要识别。

#### 小结

* 正则中 . 不包含换行
* `负向零宽先行断言` 另一种用法

### 数字

```CoffeeScript
 ( # <number>
    0[xX][ \d a-f A-F ]+
    |
    0[oO][0-7]+
    |
    0[bB][01]+
    |
    (?:
      \d*\.\d+
      |
      \d+\.? # Support one trailing dot for integers only.
    )
    (?: [eE][+-]?\d+ )?
  )
```

数字字面量识别还是很简单的，主要需要知道数字有几种形式，参考 [tc39对数字字面量的定义](https://tc39.es/ecma262/#sec-literals-numeric-literals)，主要包括：不考虑大整数，则有10进制数、2进制数整数、8进制数整数、16进制数整数，以及科学计数法等几种形式。

#### 大整数

js 中的数都是浮点数，对整数的表示是有极限的，如：

```javascript
Number.MAX_SAFE_INTEGER + 1 // 9007199254740992
Number.MAX_SAFE_INTEGER + 2 // 9007199254740992
```

因此 es 中提供了一种 大整数:

```javascript
9007199254740992n + 1n // 9007199254740993n
```

这样就解决了大数运算的问题。

显然，js-token 还未适配这种新语法。

#### x 进制数

es 中，是支持二进制整数、八进制整数、十六进制整数等字面量的：

```javascript
0b1
0o1
0x1
```

#### 科学计数法

```javascript
1.2345678901234568e+21
```

#### 符号

数字前是允许有正负号，js-token 中的数字字面量，是不包含符合的。数字的符号统一由符号识别处理。

#### 小结

* 数字字面量的几种形式
* 不对符合做处理
* 不支持大整数

### 标识

```CoffeeScript
( # <name>
  # See <http://mathiasbynens.be/notes/javascript-identifiers>.
  (?!\d)
  (?:
    (?!\s)[ $ \w \u0080-\uFFFF ]
    |
    \\u[ \d a-f A-F ]{4}
    |
    \\u\{[ \d a-f A-F ]+\}
  )+
)
```

[标识](https://tc39.es/ecma262/#prod-IdentifierName) 指的是 ES 中的一种 token，用来做 `名字和关键字（保留字）`。正则中 `\w` 等价于 `[A-Za-z0-9_]`，`(?!\s)[$ \w \u0080-\uFFFF]` 是 IdentifierPart 字符集，去掉数字就是 IdentifierStart。这里又实用了 `负向零宽先行断言`，用于将第一个匹配项中排除数字，这样就从  IdentifierPart  得到了 IdentifierStart，这个用法真是妙呀。

另外就是 `\UnicodeEscapeSequence`，用于转义，有两种形式：

```BNF
UnicodeEscapeSequence::
  uHex4Digits
  u{CodePoint}
```

#### 小结

* 标识也支持Unicode转义
* `负向零宽先行断言`妙用

### 操作符

```CoffeeScript
///
( # <punctuator>
  -- | \+\+
  |
  && | \|\|
  |
  =>
  |
  \.{3}
  |
  (?:
    [ + \- / % & | ^ ]
    |
    \*{1,2}
    |
    <{1,2} | >{1,3}
    |
    !=? | ={1,2}
  )=?
  |
  [ ? ~ . , : ; [ \] ( ) { } ]
)
///
```

#### 可赋值操作符

先看第二部分，这部分的操作符的特点是，都可以接等号做赋值操作符：如 `+=`、`-=`....。这部分操作符统一用一个 () 包起来，外部用 `=?` ，等号可又可无，精简了表达式。

#### 单字符不可赋值操作符

再看最后一部分，这部分的特点是，由单个字符组成的操作符，且后面不可跟等号。`[ ? ~ . , : ; [ \] ( ) { } ]`，这些操作符的只有单字符，因此最好识别。注意这个部分放到最后，优先让多字符的操作符先被匹配处理。

#### 多字符不可赋值操作符

由多个字符组成，且不可跟=做赋值操作符的操作符。识别操作符分为几个部分，第一部分：--、++、||、&&、=>、... 等。这些操作符的特点是：

#### 小结

* 尽量精简表达式
* 多字符和单字符书写表达式的成本不同

### 正则表达式

用 正则表达式 识别正则表达式的字面量，很有意思：

```CoffeeScript
( # <regex>
  /(?!\*)
  (?:
    \[
    (?:
      (?![ \] \\ ]).
      |
      \\.
    )*
    \]
    |
    (?![ / \] \\ ]).
    |
    \\.
  )+
  /
  (?:
    (?!
      \s*
      (?:
        \b
        |
        [ \u0080-\uFFFF $ \\ ' " ~ ( { ]
        |
        [ + \- ! ](?!=)
        |
        \.?\d
      )
    )
    |
    [ g m i y u s ]{1,6} \b
    (?!
      [ \u0080-\uFFFF $ \\ ]
      |
      \s*
      (?:
        [ + \- * % & | ^ < > ! = ? ( { ]
        |
        /(?! [ / * ] )
      )
    )
  )
)
```

还是要看[正则表达式的产生式](https://tc39.es/ecma262/#prod-RegularExpressionLiteral)：

开头不能是 * 、\、/、[ 、换行等几个字符。不过呢，`[` 可以符合 RegularExpressionClass，\ 可以符合 转义，/是结束标记，所以真正不能出现在开头的字符就是 `*` 就行了，用 `负向零宽先行断言` 将开头的 `*` 号干掉。

结尾处，使用 `负向零宽先行断言` 对结束标记后面可能的 token 做了大量的匹配，不理解这样的用意，难度是直接匹配 / 做结束标记不准吗？

## 小结

* 正则很长，一些写法很吊
* 用了大量的 `负向零宽先行断言`，很多小技巧